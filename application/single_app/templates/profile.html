<!-- templates/profile.html -->

{% extends "base.html" %}
{% block title %}
    Profile - {{ app_settings.app_title }}
{% endblock %}

{% block head %}
<style>
    .profile-hero {
        background: linear-gradient(135deg, var(--bs-primary) 0%, var(--bs-info) 100%);
        border-radius: 15px;
        padding: 3rem 2rem;
        margin-bottom: 2rem;
        color: white;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    [data-bs-theme="dark"] .profile-hero {
        background: linear-gradient(135deg, #1a3c5a 0%, #2d5973 100%);
    }
    
    .profile-hero-image {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        object-fit: cover;
        border: 5px solid rgba(255,255,255,0.3);
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    
    .profile-hero-placeholder {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        background: rgba(255,255,255,0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 5rem;
        font-weight: bold;
        border: 5px solid rgba(255,255,255,0.3);
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        backdrop-filter: blur(10px);
    }
    
    .stat-card {
        background: var(--bs-body-bg);
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        border: 1px solid var(--bs-border-color);
        transition: transform 0.2s, box-shadow 0.2s;
        height: 100%;
    }
    
    .stat-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 4px 16px rgba(0,0,0,0.12);
    }
    
    .stat-icon {
        width: 48px;
        height: 48px;
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        margin-bottom: 1rem;
    }
    
    .stat-value {
        font-size: 2rem;
        font-weight: 700;
        line-height: 1;
        margin-bottom: 0.5rem;
    }
    
    .stat-label {
        color: var(--bs-secondary-color);
        font-size: 0.875rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .stat-trend {
        font-size: 0.875rem;
        font-weight: 600;
    }
    
    .chart-card {
        background: var(--bs-body-bg);
        border-radius: 12px;
        padding: 1.5rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        border: 1px solid var(--bs-border-color);
        margin-bottom: 2rem;
    }
    
    .chart-container {
        position: relative;
        height: 300px;
    }
    
    .section-card {
        background: var(--bs-body-bg);
        border-radius: 12px;
        padding: 2rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        border: 1px solid var(--bs-border-color);
        margin-bottom: 2rem;
    }
    
    .badge-large {
        font-size: 0.875rem;
        padding: 0.5rem 1rem;
    }
    
    .timeline-item {
        padding: 1rem;
        border-left: 3px solid var(--bs-primary);
        margin-bottom: 1rem;
        background: var(--bs-light);
        border-radius: 8px;
    }
    
    [data-bs-theme="dark"] .timeline-item {
        background: rgba(255,255,255,0.05);
    }
    
    .spinning {
        animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid px-4 py-3">
    <!-- Hero Section -->
    <div class="profile-hero">
        <div class="row align-items-center">
            <div class="col-auto">
                <div id="profile-hero-image-container">
                    <!-- Profile image will be loaded here -->
                </div>
            </div>
            <div class="col">
                <h2 class="mb-2">{{ user.get('name', 'N/A') }}</h2>
                <p class="mb-3 opacity-90">
                    <i class="bi bi-envelope me-2"></i>{{ user.get('preferred_username', 'N/A') }}
                </p>
                <div class="d-flex gap-2 flex-wrap">
                    <button id="refresh-profile-image" class="btn btn-light btn-sm">
                        <i class="bi bi-arrow-clockwise"></i> Refresh Profile Image
                    </button>
                    <button id="export-activity-btn" class="btn btn-light btn-sm" data-bs-toggle="modal" data-bs-target="#exportActivityModal">
                        <i class="bi bi-download"></i> Export Activity
                    </button>
                    <span class="badge badge-large bg-light text-dark">
                        <i class="bi bi-clock me-1"></i>Last Login: <span id="last-login">Loading...</span>
                    </span>
                </div>
            </div>
        </div>
    </div>

    <!-- Cached Metrics Info -->
    <div class="alert alert-info mb-3" role="alert">
        <i class="bi bi-info-circle me-2"></i>
        <strong>Note:</strong> Total statistics below are based on cached values calculated on <span id="metrics-cached-date">Loading...</span>
    </div>

    <!-- Quick Stats -->
    <div class="row g-3 mb-4">
        <div class="col-md-3">
            <div class="stat-card">
                <div class="stat-icon bg-primary bg-opacity-10 text-primary">
                    <i class="bi bi-chat-dots"></i>
                </div>
                <div class="stat-value" id="stat-conversations">-</div>
                <div class="stat-label">Total Conversations</div>
                <div class="stat-trend text-muted" id="stat-conversations-trend"></div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="stat-card">
                <div class="stat-icon bg-success bg-opacity-10 text-success">
                    <i class="bi bi-chat-square-text"></i>
                </div>
                <div class="stat-value" id="stat-messages">-</div>
                <div class="stat-label">Total Messages</div>
                <div class="stat-trend text-muted" id="stat-messages-trend"></div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="stat-card">
                <div class="stat-icon bg-info bg-opacity-10 text-info">
                    <i class="bi bi-file-earmark-text"></i>
                </div>
                <div class="stat-value" id="stat-documents">-</div>
                <div class="stat-label">Total Documents</div>
                <div class="stat-trend text-muted" id="stat-documents-trend"></div>
            </div>
        </div>
        <div class="col-md-3">
            <div class="stat-card">
                <div class="stat-icon bg-warning bg-opacity-10 text-warning">
                    <i class="bi bi-box-arrow-in-right"></i>
                </div>
                <div class="stat-value" id="stat-logins">-</div>
                <div class="stat-label">Total Logins</div>
                <div class="stat-trend text-muted" id="stat-logins-trend"></div>
            </div>
        </div>
    </div>

    <!-- Activity Charts -->
    <div class="row g-3 mb-4">
        <div class="col-lg-6">
            <div class="chart-card">
                <h5 class="mb-3"><i class="bi bi-graph-up me-2"></i>Login Activity (Last 30 Days)</h5>
                <div class="chart-container">
                    <canvas id="loginChart"></canvas>
                </div>
            </div>
        </div>
        <div class="col-lg-6">
            <div class="chart-card">
                <h5 class="mb-3"><i class="bi bi-chat-left-dots me-2"></i>Conversation Activity (Last 30 Days)</h5>
                <div class="chart-container">
                    <canvas id="conversationChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="row g-3 mb-4">
        <div class="col-lg-6">
            <div class="chart-card">
                <h5 class="mb-3"><i class="bi bi-file-earmark-bar-graph me-2"></i>Document Activity (Last 30 Days)</h5>
                <div class="chart-container">
                    <canvas id="documentChart"></canvas>
                </div>
            </div>
        </div>
        <div class="col-lg-6">
            <div class="chart-card">
                <h5 class="mb-3"><i class="bi bi-cpu me-2"></i>Token Usage (Last 30 Days)</h5>
                <div class="chart-container">
                    <canvas id="tokenChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Storage Usage -->
    <div class="row g-3 mb-4">
        <div class="col-lg-4">
            <div class="chart-card">
                <h5 class="mb-3"><i class="bi bi-hdd me-2"></i>Storage Usage</h5>
                <div class="chart-container" style="height: 250px;">
                    <canvas id="storageChart"></canvas>
                </div>
            </div>
        </div>
        <div class="col-lg-8">
            <div class="section-card">
                <h5 class="mb-3"><i class="bi bi-person-badge me-2"></i>Account Information</h5>
                <div class="row g-3">
                    <div class="col-md-6">
                        <label class="form-label text-muted small">Name</label>
                        <div class="fw-semibold">{{ user.get('name', 'N/A') }}</div>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label text-muted small">Email</label>
                        <div class="fw-semibold">{{ user.get('preferred_username', 'N/A') }}</div>
                    </div>
                    <div class="col-md-12">
                        <label class="form-label text-muted small">Object ID</label>
                        <div class="font-monospace small">{{ user.get('oid', 'N/A') }}</div>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label text-muted small">Streaming</label>
                        <div><span id="streaming-badge" class="badge bg-secondary">-</span></div>
                    </div>
                    <div class="col-md-6">
                        <label class="form-label text-muted small">Dark Mode</label>
                        <div><span id="darkmode-badge" class="badge bg-secondary">-</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Retention Policy Settings -->
    {% if app_settings.enable_retention_policy_personal %}
    <div class="section-card">
        <h5 class="mb-3"><i class="bi bi-hourglass-split me-2"></i>Retention Policy Settings</h5>
        <p class="text-muted">Configure how long to keep your conversations and documents. Items older than the specified period will be automatically deleted.</p>
        
        <div class="alert alert-info">
            <i class="bi bi-info-circle me-2"></i>
            <strong>Default:</strong> Set to "No automatic deletion" means items are never automatically deleted. Choose a retention period to enable automatic cleanup.
        </div>
        
        <form id="retention-settings-form">
            <div class="row g-3">
                <div class="col-md-6">
                    <label for="conversation_retention_days" class="form-label">Conversation Retention</label>
                    <select class="form-select" id="conversation_retention_days" name="conversation_retention_days">
                        <option value="none">No automatic deletion</option>
                        <option value="1">1 day</option>
                        <option value="5">5 days</option>
                        <option value="10">10 days</option>
                        <option value="21">21 days (3 weeks)</option>
                        <option value="30">30 days</option>
                        <option value="60">60 days</option>
                        <option value="90">90 days (3 months)</option>
                        <option value="180">180 days (6 months)</option>
                        <option value="365">365 days (1 year)</option>
                        <option value="730">730 days (2 years)</option>
                    </select>
                    <small class="form-text text-muted">Conversations older than this will be automatically deleted.</small>
                </div>
                
                <div class="col-md-6">
                    <label for="document_retention_days" class="form-label">Document Retention</label>
                    <select class="form-select" id="document_retention_days" name="document_retention_days">
                        <option value="none">No automatic deletion</option>
                        <option value="1">1 day</option>
                        <option value="5">5 days</option>
                        <option value="10">10 days</option>
                        <option value="21">21 days (3 weeks)</option>
                        <option value="30">30 days</option>
                        <option value="60">60 days</option>
                        <option value="90">90 days (3 months)</option>
                        <option value="180">180 days (6 months)</option>
                        <option value="365">365 days (1 year)</option>
                        <option value="730">730 days (2 years)</option>
                    </select>
                    <small class="form-text text-muted">Documents older than this will be automatically deleted.</small>
                </div>
            </div>
            
            <div class="mt-3">
                <button type="button" class="btn btn-primary" onclick="saveRetentionSettings()">
                    <i class="bi bi-save me-1"></i>Save Retention Settings
                </button>
                <span id="retention-save-status" class="ms-3"></span>
            </div>
        </form>
        
        <div class="alert alert-warning mt-3 mb-0">
            <i class="bi bi-exclamation-triangle me-2"></i>
            <strong>Important:</strong> Deleted conversations will be archived if archiving is enabled. All deletions are logged in activity history.
        </div>
    </div>
    {% endif %}

    <!-- Speech & Microphone Settings -->
    {% if app_settings.enable_speech_to_text_input %}
    <div class="section-card" id="speech-settings">
        <h5 class="mb-3"><i class="bi bi-mic-fill me-2"></i>Speech & Microphone Settings</h5>
        <p class="text-muted">Manage how microphone permissions are handled for speech-to-text input.</p>
        
        <div class="mb-3">
            <label class="form-label fw-semibold">Current Permission Status</label>
            <div class="d-flex align-items-center gap-2">
                <span id="microphone-status-badge" class="badge bg-secondary">
                    <i class="bi bi-question-circle me-1"></i>Unknown
                </span>
                <button type="button" class="btn btn-sm btn-outline-primary" id="microphone-permission-btn" onclick="toggleMicrophonePermission()">
                    <i class="bi bi-mic-fill me-1"></i>Request Permission
                </button>
            </div>
            <small class="text-muted">This shows your browser's current microphone permission status. Use the button to request or revoke permission.</small>
        </div>
        
        <div class="alert alert-info mt-3 mb-0">
            <i class="bi bi-info-circle me-2"></i>
            <strong>Note:</strong> If the microphone icon appears red in chat, click it to return to this page and manage your permissions. 
            You can also manage browser-level permissions through your browser settings.
        </div>
    </div>
    {% endif %}

    <!-- Text-to-Speech Settings -->
    {% if app_settings.enable_text_to_speech %}
    <div class="section-card" id="tts-settings">
        <h5 class="mb-3"><i class="bi bi-volume-up-fill me-2"></i>Text-to-Speech Settings</h5>
        <p class="text-muted">Configure AI voice responses for assistant messages.</p>
        
        <div class="mb-3">
            <label for="tts-voice-select" class="form-label fw-semibold">Voice Selection</label>
            <select class="form-select" id="tts-voice-select" onchange="updateVoicePreview()">
                <option value="">Select a voice...</option>
                <!-- Voice options will be populated by JavaScript -->
            </select>
            <small class="text-muted">Choose the voice that will read AI assistant messages aloud.</small>
        </div>
        
        <div class="mb-3">
            <label for="tts-speed-slider" class="form-label fw-semibold">Speech Speed: <span id="tts-speed-value">1.0x</span></label>
            <input type="range" class="form-range" id="tts-speed-slider" 
                   min="0.5" max="2.0" step="0.1" value="1.0" 
                   oninput="updateSpeedValue(this.value)">
            <div class="d-flex justify-content-between">
                <small class="text-muted">0.5x (Slower)</small>
                <small class="text-muted">2.0x (Faster)</small>
            </div>
        </div>
        
        <div class="mb-3">
            <label class="form-label fw-semibold">Voice Preview</label>
            <div class="d-flex align-items-center gap-2">
                <button type="button" class="btn btn-sm btn-outline-primary" id="tts-preview-btn" onclick="playVoicePreview()">
                    <i class="bi bi-play-circle me-1"></i>Play Sample
                </button>
                <button type="button" class="btn btn-sm btn-outline-danger" id="tts-stop-btn" onclick="stopVoicePreview()" style="display: none;">
                    <i class="bi bi-stop-circle me-1"></i>Stop
                </button>
                <span id="tts-preview-status" class="text-muted small"></span>
            </div>
            <small class="text-muted">Test the selected voice with a sample phrase.</small>
        </div>
        
        <div class="form-check form-switch mb-3">
            <input class="form-check-input" type="checkbox" id="tts-autoplay-toggle">
            <label class="form-check-label" for="tts-autoplay-toggle">
                Enable Auto-play for AI Responses
            </label>
            <small class="d-block text-muted">When enabled, AI responses will automatically be read aloud. Streaming will be disabled when auto-play is on.</small>
        </div>
        
        <button type="button" class="btn btn-primary" onclick="saveTTSSettings()">
            <i class="bi bi-save me-1"></i>Save Voice Settings
        </button>
        
        <div class="alert alert-info mt-3 mb-0">
            <i class="bi bi-info-circle me-2"></i>
            <strong>Tip:</strong> You can also enable voice playback for individual messages using the "Listen" button in the chat interface.
        </div>
    </div>
    {% endif %}

    <p class="text-muted mt-4 text-center">Version: {{ config['VERSION'] }}</p>
</div>

<!-- Microphone Permission Instructions Modal -->
<div class="modal fade" id="microphonePermissionModal" tabindex="-1" aria-labelledby="microphonePermissionModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="microphonePermissionModalLabel">
                    <i class="bi bi-mic-mute-fill me-2"></i>Microphone Permission Blocked
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning" role="alert">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>This page is blocked from accessing your microphone.</strong>
                </div>
                
                <h6 class="fw-bold mb-3">To enable microphone access:</h6>
                
                <ol class="mb-3">
                    <li class="mb-3">
                        <strong>Look for the microphone icon</strong> in the right side of your browser's address bar
                        <div class="text-muted small mt-1">
                            <i class="bi bi-mic-mute-fill"></i> It will have a line through it indicating it's blocked
                        </div>
                    </li>
                    <li class="mb-3">
                        Click <strong>the microphone icon</strong> (<i class="bi bi-mic-mute-fill"></i>) to open the permission menu
                    </li>
                    <li class="mb-3">
                        Select <strong>"Always allow"</strong> to grant microphone access
                    </li>
                    <li class="mb-3">
                        Click <strong>"Done"</strong> and refresh this page
                    </li>
                </ol>
                
                <div class="alert alert-info mb-0" role="alert">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Note:</strong> Once blocked, browsers won't ask for permission again until you manually change the setting.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="window.location.reload()">
                    <i class="bi bi-arrow-clockwise me-1"></i>Refresh Page
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Microphone Permission Revoke Modal -->
<div class="modal fade" id="microphoneRevokeModal" tabindex="-1" aria-labelledby="microphoneRevokeModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header bg-warning text-dark">
                <h5 class="modal-title" id="microphoneRevokeModalLabel">
                    <i class="bi bi-mic-mute-fill me-2"></i>Revoke Microphone Permission
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info" role="alert">
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>Microphone access is currently granted.</strong>
                </div>
                
                <h6 class="fw-bold mb-3">To revoke/block microphone access:</h6>
                
                <ol class="mb-3">
                    <li class="mb-3">
                        <strong>Look for the microphone icon</strong> in the right side of your browser's address bar
                        <div class="text-muted small mt-1">
                            <i class="bi bi-mic-fill"></i> It will be shown without a line, indicating it's allowed
                        </div>
                    </li>
                    <li class="mb-3">
                        Click <strong>the microphone icon</strong> (<i class="bi bi-mic-fill"></i>) to open the permission menu
                    </li>
                    <li class="mb-3">
                        <strong>Select "Continue blocking"</strong>, <strong>Select "Always block microphone access"</strong>, or <strong>Select "Block"</strong>
                    </li>
                    <li class="mb-3">
                        Click <strong>"Done"</strong> and refresh this page
                    </li>
                </ol>
                
                <div class="alert alert-warning mb-0" role="alert">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>Note:</strong> Revoking permission will prevent speech-to-text from working until you allow it again.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="window.location.reload()">
                    <i class="bi bi-arrow-clockwise me-1"></i>Refresh Page
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Export Activity Modal -->
<div class="modal fade" id="exportActivityModal" tabindex="-1" aria-labelledby="exportActivityModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="exportActivityModalLabel">
                    <i class="bi bi-download me-2"></i>Export Activity Data
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label fw-semibold">Select Data to Export</label>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="exportLogins" checked>
                        <label class="form-check-label" for="exportLogins">
                            Login Activity (Last 30 Days)
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="exportConversations" checked>
                        <label class="form-check-label" for="exportConversations">
                            Conversation Activity (Last 30 Days)
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="exportDocuments" checked>
                        <label class="form-check-label" for="exportDocuments">
                            Document Activity (Last 30 Days)
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="exportTokens" checked>
                        <label class="form-check-label" for="exportTokens">
                            Token Usage (Last 30 Days)
                        </label>
                    </div>
                    <div class="form-check mt-2">
                        <input class="form-check-input" type="checkbox" id="exportMetrics" checked>
                        <label class="form-check-label" for="exportMetrics">
                            Summary Metrics (Totals)
                        </label>
                    </div>
                </div>
                
                <div class="alert alert-info mb-0">
                    <i class="bi bi-info-circle me-2"></i>
                    Data will be exported as a CSV file that you can open in Excel or other spreadsheet applications.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="exportActivityData()">
                    <i class="bi bi-download me-1"></i>Export CSV
                </button>
            </div>
        </div>
    </div>
</div>

<script src="{{ url_for('static', filename='js/chart.min.js') }}"></script>
<script src="{{ url_for('static', filename='js/chart.min.js') }}"></script>
<script>
// Initialize charts
let loginChart, conversationChart, documentChart, tokenChart, storageChart;

console.log('Profile page script loaded - preparing to initialize');

// Profile hero image function
function updateProfileHeroImage() {
    console.log('updateProfileHeroImage called');
    const container = document.getElementById('profile-hero-image-container');
    const userName = '{{ user.get("name", "User") }}';
    
    if (!container) {
        console.error('ERROR: profile-hero-image-container not found in DOM!');
        return;
    }
    
    // Get profile image from sessionStorage (updated by profile-image.js)
    const profileImageData = sessionStorage.getItem('userProfileImage');
    console.log('Profile image from session:', profileImageData ? 'Found (' + profileImageData.length + ' chars)' : 'Not found');
    
    if (profileImageData && profileImageData.startsWith('data:image')) {
        console.log('Rendering profile image in hero');
        container.innerHTML = `<img src="${profileImageData}" alt="Profile Image" class="profile-hero-image">`;
    } else {
        console.log('Rendering placeholder in hero');
        const initials = userName.split(' ').map(name => name.charAt(0)).join('').toUpperCase().substring(0, 2);
        container.innerHTML = `<div class="profile-hero-placeholder">${initials}</div>`;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('Profile DOMContentLoaded fired');
    
    // Use the global profile-image.js functions
    console.log('Calling loadUserProfileImage from profile-image.js');
    if (typeof loadUserProfileImage === 'function') {
        loadUserProfileImage();
        // Wait a bit for the image to load, then update hero
        setTimeout(() => {
            updateProfileHeroImage();
        }, 500);
    } else {
        console.error('loadUserProfileImage not available!');
    }
    
    loadRetentionSettings();
    loadMicrophoneSettings();
    loadUserMetrics();
    initializeCharts();
    
    // Initialize TTS settings if enabled
    {% if app_settings.enable_text_to_speech %}
    loadTTSSettings();
    {% endif %}
    
    document.getElementById('refresh-profile-image').addEventListener('click', function() {
        if (typeof window.ProfileImage !== 'undefined' && window.ProfileImage.refresh) {
            window.ProfileImage.refresh().then(() => {
                updateProfileHeroImage();
            });
        } else {
            loadUserProfileImage();
            setTimeout(() => {
                updateProfileHeroImage();
            }, 500);
        }
    });
});

function loadUserMetrics() {
    fetch('/api/user/settings')
        .then(response => response.json())
        .then(data => {
            const metrics = data.settings?.metrics || {};
            
            // Update stat cards
            const loginMetrics = metrics.login_metrics || {};
            const chatMetrics = metrics.chat_metrics || {};
            const documentMetrics = metrics.document_metrics || {};
            
            document.getElementById('stat-conversations').textContent = formatNumber(chatMetrics.total_conversations || 0);
            document.getElementById('stat-messages').textContent = formatNumber(chatMetrics.total_messages || 0);
            document.getElementById('stat-documents').textContent = formatNumber(documentMetrics.total_documents || 0);
            document.getElementById('stat-logins').textContent = formatNumber(loginMetrics.total_logins || 0);
            
            // Update last login
            if (loginMetrics.last_login) {
                document.getElementById('last-login').textContent = formatRelativeTime(loginMetrics.last_login);
            }
            
            // Update cached metrics date
            if (metrics.calculated_at) {
                document.getElementById('metrics-cached-date').textContent = formatRelativeTime(metrics.calculated_at);
            } else {
                document.getElementById('metrics-cached-date').textContent = 'Unknown';
            }
            
            // Update preferences badges
            document.getElementById('streaming-badge').textContent = data.settings?.streamingEnabled ? 'Enabled' : 'Disabled';
            document.getElementById('streaming-badge').className = `badge ${data.settings?.streamingEnabled ? 'bg-success' : 'bg-secondary'}`;
            
            document.getElementById('darkmode-badge').textContent = data.settings?.darkModeEnabled ? 'Enabled' : 'Disabled';
            document.getElementById('darkmode-badge').className = `badge ${data.settings?.darkModeEnabled ? 'bg-dark' : 'bg-light text-dark'}`;
            
            // Load time-series data for charts
            loadActivityChartData();
        })
        .catch(error => {
            console.error('Error loading user metrics:', error);
        });
}

function loadActivityChartData() {
    // Fetch activity trends data
    fetch('/api/user/activity-trends?days=30')
        .then(response => response.json())
        .then(data => {
            console.log('Activity trends data received:', data);
            console.log('Logins:', data.logins);
            console.log('Conversations:', data.conversations);
            console.log('Documents:', data.documents);
            console.log('Tokens:', data.tokens);
            console.log('Storage:', data.storage);
            
            updateLoginChart(data.logins || []);
            updateConversationChart(data.conversations || []);
            updateDocumentChart(data.documents || []);
            updateTokenChart(data.tokens || []);
            updateStorageChart(data.storage || {});
        })
        .catch(error => {
            console.error('Error loading activity trends:', error);
            // Show sample data on error
            updateLoginChart([]);
            updateConversationChart([]);
            updateDocumentChart([]);
            updateTokenChart([]);
            updateStorageChart({});
        });
}

function initializeCharts() {
    const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
    const gridColor = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
    const textColor = isDark ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.7)';
    
    Chart.defaults.color = textColor;
    Chart.defaults.borderColor = gridColor;
    
    // Initialize empty charts
    const ctx1 = document.getElementById('loginChart').getContext('2d');
    loginChart = new Chart(ctx1, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: getLineChartOptions('Logins')
    });
    
    const ctx2 = document.getElementById('conversationChart').getContext('2d');
    conversationChart = new Chart(ctx2, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: getBarChartOptions('Conversations')
    });
    
    const ctx3 = document.getElementById('documentChart').getContext('2d');
    documentChart = new Chart(ctx3, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: getBarChartOptions('Documents')
    });
    
    const ctx4 = document.getElementById('tokenChart').getContext('2d');
    tokenChart = new Chart(ctx4, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: getLineChartOptions('Tokens (Millions)')
    });
    
    const ctx5 = document.getElementById('storageChart').getContext('2d');
    storageChart = new Chart(ctx5, {
        type: 'doughnut',
        data: { labels: [], datasets: [] },
        options: getDoughnutChartOptions()
    });
}

function getLineChartOptions(label) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            tooltip: {
                mode: 'index',
                intersect: false
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                ticks: { precision: 0 }
            }
        }
    };
}

function getBarChartOptions(label) {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: { display: false },
            tooltip: {
                mode: 'index',
                intersect: false
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                ticks: { precision: 0 }
            }
        }
    };
}

function getDoughnutChartOptions() {
    return {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                position: 'bottom'
            },
            tooltip: {
                callbacks: {
                    label: function(context) {
                        return context.label + ': ' + formatBytes(context.parsed);
                    }
                }
            }
        }
    };
}

function updateLoginChart(data) {
    const last30Days = getLast30Days();
    const values = last30Days.map(date => {
        const found = data.find(d => d.date === date);
        return found ? found.count : 0;
    });
    
    console.log('Login chart - last30Days:', last30Days);
    console.log('Login chart - values:', values);
    
    loginChart.data.labels = last30Days.map(d => formatDate(d));
    loginChart.data.datasets = [{
        label: 'Logins',
        data: values,
        borderColor: '#ffc107',
        backgroundColor: 'rgba(255, 193, 7, 0.1)',
        tension: 0.4,
        fill: true
    }];
    loginChart.update();
}

function updateConversationChart(data) {
    const last30Days = getLast30Days();
    
    // Handle both old format (array) and new format (object with creates/deletes)
    let createValues, deleteValues;
    
    if (data.creates && data.deletes) {
        // New format with separate creates and deletes
        createValues = last30Days.map(date => {
            const found = data.creates.find(d => d.date === date);
            return found ? found.count : 0;
        });
        deleteValues = last30Days.map(date => {
            const found = data.deletes.find(d => d.date === date);
            return found ? found.count : 0;
        });
    } else {
        // Old format - treat as creates only
        createValues = last30Days.map(date => {
            const found = data.find(d => d.date === date);
            return found ? found.count : 0;
        });
        deleteValues = last30Days.map(() => 0);
    }
    
    conversationChart.data.labels = last30Days.map(d => formatDate(d));
    conversationChart.data.datasets = [
        {
            label: 'Created',
            data: createValues,
            backgroundColor: 'rgba(13, 110, 253, 0.8)',
            borderColor: '#0d6efd',
            borderWidth: 1
        },
        {
            label: 'Deleted',
            data: deleteValues,
            backgroundColor: 'rgba(220, 53, 69, 0.8)',
            borderColor: '#dc3545',
            borderWidth: 1
        }
    ];
    conversationChart.update();
}

function updateDocumentChart(data) {
    const last30Days = getLast30Days();
    
    // Handle both old format (array) and new format (object with uploads/deletes)
    let uploadValues, deleteValues;
    
    if (data.uploads && data.deletes) {
        // New format with separate uploads and deletes
        uploadValues = last30Days.map(date => {
            const found = data.uploads.find(d => d.date === date);
            return found ? found.count : 0;
        });
        deleteValues = last30Days.map(date => {
            const found = data.deletes.find(d => d.date === date);
            return found ? found.count : 0;
        });
    } else {
        // Old format - treat as uploads only
        uploadValues = last30Days.map(date => {
            const found = data.find(d => d.date === date);
            return found ? found.count : 0;
        });
        deleteValues = last30Days.map(() => 0);
    }
    
    documentChart.data.labels = last30Days.map(d => formatDate(d));
    documentChart.data.datasets = [
        {
            label: 'Uploads',
            data: uploadValues,
            backgroundColor: 'rgba(13, 202, 240, 0.8)',
            borderColor: '#0dcaf0',
            borderWidth: 1
        },
        {
            label: 'Deletes',
            data: deleteValues,
            backgroundColor: 'rgba(220, 53, 69, 0.8)',
            borderColor: '#dc3545',
            borderWidth: 1
        }
    ];
    documentChart.update();
}

function updateTokenChart(data) {
    const last30Days = getLast30Days();
    const values = last30Days.map(date => {
        const found = data.find(d => d.date === date);
        return found ? (found.tokens / 1000000) : 0; // Convert to millions
    });
    
    tokenChart.data.labels = last30Days.map(d => formatDate(d));
    tokenChart.data.datasets = [{
        label: 'Tokens',
        data: values,
        borderColor: '#198754',
        backgroundColor: 'rgba(25, 135, 84, 0.1)',
        tension: 0.4,
        fill: true
    }];
    tokenChart.update();
}

function updateStorageChart(data) {
    const aiSearch = data.ai_search_size || 0;
    const blobStorage = data.storage_account_size || 0;
    
    storageChart.data.labels = ['AI Search', 'Blob Storage'];
    storageChart.data.datasets = [{
        data: [aiSearch, blobStorage],
        backgroundColor: ['#0d6efd', '#17a2b8'],
        borderWidth: 2
    }];
    storageChart.update();
}

function getLast30Days() {
    const days = [];
    for (let i = 29; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        days.push(date.toISOString().split('T')[0]);
    }
    return days;
}

function formatDate(dateStr) {
    const date = new Date(dateStr);
    return (date.getMonth() + 1) + '/' + date.getDate();
}

function formatNumber(num) {
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toString();
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

function formatRelativeTime(dateStr) {
    const date = new Date(dateStr);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'Just now';
    if (diffMins < 60) return diffMins + ' min ago';
    if (diffHours < 24) return diffHours + ' hr ago';
    if (diffDays < 7) return diffDays + ' day' + (diffDays > 1 ? 's' : '') + ' ago';
    return date.toLocaleDateString();
}

function loadRetentionSettings() {
    fetch('/api/user/settings')
        .then(response => response.json())
        .then(data => {
            const retentionPolicy = data.settings?.retention_policy || {};
            
            const convRetention = retentionPolicy.conversation_retention_days || 'none';
            const docRetention = retentionPolicy.document_retention_days || 'none';
            
            const convSelect = document.getElementById('conversation_retention_days');
            const docSelect = document.getElementById('document_retention_days');
            
            if (convSelect) convSelect.value = convRetention;
            if (docSelect) docSelect.value = docRetention;
        })
        .catch(error => {
            console.error('Error loading retention settings:', error);
        });
}

function saveRetentionSettings() {
    const convRetention = document.getElementById('conversation_retention_days').value;
    const docRetention = document.getElementById('document_retention_days').value;
    
    const statusElement = document.getElementById('retention-save-status');
    statusElement.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
    statusElement.className = 'text-info';
    
    fetch('/api/retention-policy/user', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            conversation_retention_days: convRetention,
            document_retention_days: docRetention
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            statusElement.innerHTML = '<i class="bi bi-check-circle"></i> Settings saved successfully!';
            statusElement.className = 'text-success';
            
            setTimeout(() => {
                statusElement.innerHTML = '';
            }, 3000);
        } else {
            statusElement.innerHTML = '<i class="bi bi-exclamation-circle"></i> Error: ' + (data.error || 'Failed to save');
            statusElement.className = 'text-danger';
        }
    })
    .catch(error => {
        statusElement.innerHTML = '<i class="bi bi-exclamation-circle"></i> Error: ' + error.message;
        statusElement.className = 'text-danger';
    });
}

function loadMicrophoneSettings() {
    // Check if microphone settings section exists (only if speech-to-text is enabled)
    if (!document.getElementById('speech-settings')) {
        return;
    }
    
    // Check actual browser permission state
    checkMicrophonePermissionStatus();
}

async function checkMicrophonePermissionStatus() {
    // Try to access microphone to determine actual permission state
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        updateMicrophoneStatusBadge('prompt');
        return;
    }
    
    try {
        // Request microphone access (will use cached permission, won't prompt again)
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Permission is granted - stop the stream immediately
        stream.getTracks().forEach(track => track.stop());
        updateMicrophoneStatusBadge('granted');
        
    } catch (error) {
        // Check error type to determine state
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            // Permission was denied
            updateMicrophoneStatusBadge('denied');
        } else if (error.name === 'NotFoundError') {
            // No microphone device found
            updateMicrophoneStatusBadge('prompt');
        } else {
            // Other error - default to prompt
            console.log('Microphone permission check error:', error.name, error.message);
            updateMicrophoneStatusBadge('prompt');
        }
    }
}

function updateMicrophoneStatusBadge(status) {
    const badge = document.getElementById('microphone-status-badge');
    const button = document.getElementById('microphone-permission-btn');
    if (!badge) return;
    
    switch(status) {
        case 'granted':
            badge.className = 'badge bg-success';
            badge.innerHTML = '<i class="bi bi-check-circle-fill me-1"></i>Granted';
            if (button) {
                button.className = 'btn btn-sm btn-outline-danger';
                button.innerHTML = '<i class="bi bi-mic-mute-fill me-1"></i>Revoke Permission';
            }
            break;
        case 'denied':
            badge.className = 'badge bg-danger';
            badge.innerHTML = '<i class="bi bi-x-circle-fill me-1"></i>Denied';
            if (button) {
                button.className = 'btn btn-sm btn-outline-primary';
                button.innerHTML = '<i class="bi bi-mic-fill me-1"></i>Request Permission';
            }
            break;
        case 'prompt':
        default:
            badge.className = 'badge bg-secondary';
            badge.innerHTML = '<i class="bi bi-question-circle me-1"></i>Not Determined';
            if (button) {
                button.className = 'btn btn-sm btn-outline-primary';
                button.innerHTML = '<i class="bi bi-mic-fill me-1"></i>Request Permission';
            }
            break;
    }
}

async function requestMicrophonePermission() {
    // Request microphone permission - this will trigger the browser's permission dialog if possible
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert('Your browser does not support microphone access.');
        return;
    }
    
    try {
        // Always attempt to request microphone access
        // If permission is 'prompt', this will show the browser's native permission dialog
        // If permission is 'denied', this will immediately throw an error
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Permission granted - stop the stream and update UI
        stream.getTracks().forEach(track => track.stop());
        updateMicrophoneStatusBadge('granted');
        showToastMessage('Microphone access granted!', 'success');
        
    } catch (error) {
        // Check error type
        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
            // Permission was denied (either just now or already blocked)
            updateMicrophoneStatusBadge('denied');
            
            // Show modal with helpful instructions
            const modal = new bootstrap.Modal(document.getElementById('microphonePermissionModal'));
            modal.show();
        } else if (error.name === 'NotFoundError') {
            // No microphone found
            alert('No microphone device was found on your system. Please connect a microphone and try again.');
        } else {
            // Other error
            console.error('Microphone permission error:', error);
            alert('Error accessing microphone: ' + error.message);
        }
    }
}

async function toggleMicrophonePermission() {
    const badge = document.getElementById('microphone-status-badge');
    const currentStatus = badge?.textContent.includes('Granted') ? 'granted' : 'other';
    
    if (currentStatus === 'granted') {
        // Show revoke modal
        revokeMicrophonePermission();
    } else {
        // Request permission
        requestMicrophonePermission();
    }
}

async function revokeMicrophonePermission() {
    // Activate microphone to show the browser's permission indicator in the address bar
    let micStream = null;
    
    try {
        // Request microphone access - this will make the browser show the mic icon
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Show modal with instructions
        const modalElement = document.getElementById('microphoneRevokeModal');
        const modal = new bootstrap.Modal(modalElement);
        
        // Clean up the stream when modal is closed
        modalElement.addEventListener('hidden.bs.modal', () => {
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
                micStream = null;
            }
        }, { once: true });
        
        modal.show();
        
    } catch (error) {
        console.error('Error accessing microphone for revoke:', error);
        // Show modal anyway with instructions
        const modal = new bootstrap.Modal(document.getElementById('microphoneRevokeModal'));
        modal.show();
    }
}

function showToastMessage(message, type) {
    const bgClass = type === 'success' ? 'bg-success' : type === 'info' ? 'bg-info' : 'bg-primary';
    const toast = document.createElement('div');
    toast.className = `toast align-items-center text-white ${bgClass} border-0`;
    toast.setAttribute('role', 'alert');
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                <i class="bi bi-${type === 'success' ? 'check-circle' : 'info-circle'} me-2"></i>${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
    `;
    document.body.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
    toast.addEventListener('hidden.bs.toast', () => toast.remove());
}

function refreshProfileImage() {
    const button = document.getElementById('refresh-profile-image');
    const originalText = button.innerHTML;
    
    // Show loading state
    button.innerHTML = '<i class="bi bi-arrow-clockwise spinning"></i> Refreshing...';
    button.disabled = true;
    
    // Use the global ProfileImage utility if available
    if (window.ProfileImage && window.ProfileImage.refresh) {
        window.ProfileImage.refresh()
            .then(data => {
                displayProfileImage(data.profileImage);
                showSuccessToast(data.message);
            })
            .catch(error => {
                console.error('Error refreshing profile image:', error);
                alert('Error refreshing profile image: ' + error.message);
            })
            .finally(() => {
                // Restore button state
                button.innerHTML = originalText;
                button.disabled = false;
            });
    } else {
        // Fallback to direct API call
        fetch('/api/profile/image/refresh', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                displayProfileImage(data.profileImage);
                showSuccessToast(data.message);
            } else {
                console.error('Error refreshing profile image:', data.error);
                alert('Error refreshing profile image: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error refreshing profile image:', error);
            alert('Error refreshing profile image: ' + error.message);
        })
        .finally(() => {
            // Restore button state
            button.innerHTML = originalText;
            button.disabled = false;
        });
    }
}

function showSuccessToast(message) {
    // Show success message
    const toast = document.createElement('div');
    toast.className = 'toast align-items-center text-white bg-success border-0';
    toast.setAttribute('role', 'alert');
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
    `;
    
    document.body.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
    
    // Remove toast after it's hidden
    toast.addEventListener('hidden.bs.toast', () => {
        toast.remove();
    });
}

function loadRetentionSettings() {
    fetch('/api/user/settings')
        .then(response => response.json())
        .then(data => {
            const retentionPolicy = data.settings?.retention_policy || {};
            
            const convRetention = retentionPolicy.conversation_retention_days || 'none';
            const docRetention = retentionPolicy.document_retention_days || 'none';
            
            const convSelect = document.getElementById('conversation_retention_days');
            const docSelect = document.getElementById('document_retention_days');
            
            if (convSelect) convSelect.value = convRetention;
            if (docSelect) docSelect.value = docRetention;
        })
        .catch(error => {
            console.error('Error loading retention settings:', error);
        });
}

function saveRetentionSettings() {
    const convRetention = document.getElementById('conversation_retention_days').value;
    const docRetention = document.getElementById('document_retention_days').value;
    
    const statusElement = document.getElementById('retention-save-status');
    statusElement.innerHTML = '<i class="bi bi-hourglass-split"></i> Saving...';
    statusElement.className = 'text-info';
    
    fetch('/api/retention-policy/user', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            conversation_retention_days: convRetention,
            document_retention_days: docRetention
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            statusElement.innerHTML = '<i class="bi bi-check-circle"></i> Settings saved successfully!';
            statusElement.className = 'text-success';
            
            setTimeout(() => {
                statusElement.innerHTML = '';
            }, 3000);
        } else {
            statusElement.innerHTML = '<i class="bi bi-exclamation-circle"></i> Error: ' + (data.error || 'Failed to save');
            statusElement.className = 'text-danger';
        }
    })
    .catch(error => {
        statusElement.innerHTML = '<i class="bi bi-exclamation-circle"></i> Error: ' + error.message;
        statusElement.className = 'text-danger';
    });
}

function showSuccessToast(message) {
    // Show success message
    const toast = document.createElement('div');
    toast.className = 'toast align-items-center text-white bg-success border-0';
    toast.setAttribute('role', 'alert');
    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
    `;
    
    document.body.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();
    
    // Remove toast after it's hidden
    toast.addEventListener('hidden.bs.toast', () => {
        toast.remove();
    });
}

// Export activity data to CSV
function exportActivityData() {
    const includeLogins = document.getElementById('exportLogins').checked;
    const includeConversations = document.getElementById('exportConversations').checked;
    const includeDocuments = document.getElementById('exportDocuments').checked;
    const includeTokens = document.getElementById('exportTokens').checked;
    const includeMetrics = document.getElementById('exportMetrics').checked;
    
    if (!includeLogins && !includeConversations && !includeDocuments && !includeTokens && !includeMetrics) {
        alert('Please select at least one data type to export.');
        return;
    }
    
    // Close modal
    const modal = bootstrap.Modal.getInstance(document.getElementById('exportActivityModal'));
    modal.hide();
    
    // Fetch activity data
    Promise.all([
        fetch('/api/user/activity-trends?days=30').then(r => r.json()),
        fetch('/api/user/settings').then(r => r.json())
    ])
    .then(([trendsData, settingsData]) => {
        let csvContent = '';
        const metrics = settingsData.settings?.metrics || {};
        const userName = '{{ user.get("name", "User") }}';
        const userEmail = '{{ user.get("preferred_username", "N/A") }}';
        
        // Add header with user info
        csvContent += `User Activity Export\n`;
        csvContent += `User: ${userName}\n`;
        csvContent += `Email: ${userEmail}\n`;
        csvContent += `Export Date: ${new Date().toLocaleString()}\n`;
        csvContent += `Data Period: Last 30 Days\n\n`;
        
        // Add summary metrics if selected
        if (includeMetrics && metrics) {
            csvContent += `SUMMARY METRICS\n`;
            csvContent += `Metric,Value\n`;
            
            if (metrics.login_metrics) {
                csvContent += `Total Logins,${metrics.login_metrics.total_logins || 0}\n`;
                csvContent += `Last Login,${metrics.login_metrics.last_login || 'Never'}\n`;
            }
            
            if (metrics.chat_metrics) {
                csvContent += `Total Conversations,${metrics.chat_metrics.total_conversations || 0}\n`;
                csvContent += `Total Messages,${metrics.chat_metrics.total_messages || 0}\n`;
                csvContent += `Total Message Size (bytes),${metrics.chat_metrics.total_message_size || 0}\n`;
            }
            
            if (metrics.document_metrics) {
                csvContent += `Total Documents,${metrics.document_metrics.total_documents || 0}\n`;
                csvContent += `AI Search Size (bytes),${metrics.document_metrics.ai_search_size || 0}\n`;
                csvContent += `Storage Size (bytes),${metrics.document_metrics.storage_account_size || 0}\n`;
            }
            
            if (metrics.calculated_at) {
                csvContent += `Metrics Calculated At,${metrics.calculated_at}\n`;
            }
            
            csvContent += `\n`;
        }
        
        // Add login activity
        if (includeLogins && trendsData.logins) {
            csvContent += `LOGIN ACTIVITY (Last 30 Days)\n`;
            csvContent += `Date,Logins\n`;
            trendsData.logins.forEach(item => {
                csvContent += `${item.date},${item.count}\n`;
            });
            csvContent += `\n`;
        }
        
        // Add conversation activity
        if (includeConversations && trendsData.conversations) {
            csvContent += `CONVERSATION ACTIVITY (Last 30 Days)\n`;
            csvContent += `Date,Conversations Created\n`;
            trendsData.conversations.forEach(item => {
                csvContent += `${item.date},${item.count}\n`;
            });
            csvContent += `\n`;
        }
        
        // Add document activity
        if (includeDocuments && trendsData.documents) {
            csvContent += `DOCUMENT ACTIVITY (Last 30 Days)\n`;
            csvContent += `Date,Documents Uploaded\n`;
            trendsData.documents.forEach(item => {
                csvContent += `${item.date},${item.count}\n`;
            });
            csvContent += `\n`;
        }
        
        // Add token usage
        if (includeTokens && trendsData.tokens) {
            csvContent += `TOKEN USAGE (Last 30 Days)\n`;
            csvContent += `Date,Total Tokens\n`;
            trendsData.tokens.forEach(item => {
                csvContent += `${item.date},${item.tokens}\n`;
            });
            csvContent += `\n`;
        }
        
        // Create and download file
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        const filename = `activity_export_${new Date().toISOString().split('T')[0]}.csv`;
        
        link.setAttribute('href', url);
        link.setAttribute('download', filename);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showSuccessToast('Activity data exported successfully!');
    })
    .catch(error => {
        console.error('Error exporting activity data:', error);
        alert('Error exporting activity data. Please try again.');
    });
}

// Text-to-Speech Settings Functions
{% if app_settings.enable_text_to_speech %}
let ttsVoices = [];
let currentAudio = null;

async function loadTTSSettings() {
    try {
        // Load available voices
        const voicesResponse = await fetch('/api/chat/tts/voices');
        const voicesData = await voicesResponse.json();
        ttsVoices = voicesData.voices || [];
        
        // Populate voice dropdown
        const voiceSelect = document.getElementById('tts-voice-select');
        voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
        
        // Group voices by language
        const languageGroups = {};
        ttsVoices.forEach(voice => {
            const lang = voice.language || 'Other';
            if (!languageGroups[lang]) {
                languageGroups[lang] = [];
            }
            languageGroups[lang].push(voice);
        });
        
        // Add grouped options
        Object.keys(languageGroups).sort().forEach(lang => {
            const optgroup = document.createElement('optgroup');
            optgroup.label = lang;
            languageGroups[lang].forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                const displayName = voice.name.split(':')[0].split('-').pop(); // Extract just the name
                const genderBadge = voice.gender === 'Male' ? '' : voice.gender === 'Female' ? '' : '';
                const statusBadge = voice.status === 'Preview' ? ' [Preview]' : '';
                option.textContent = `${displayName} ${genderBadge}${statusBadge}`;
                if (voice.note) {
                    option.textContent += ` - ${voice.note}`;
                }
                optgroup.appendChild(option);
            });
            voiceSelect.appendChild(optgroup);
        });
        
        // Load user's saved settings
        const response = await fetch('/api/user/settings');
        const data = await response.json();
        const settings = data.settings || {};
        
        // Apply saved settings
        if (settings.ttsVoice) {
            voiceSelect.value = settings.ttsVoice;
        } else {
            // Default to Andrew
            voiceSelect.value = 'en-US-Andrew:DragonHDLatestNeural';
        }
        
        if (settings.ttsSpeed) {
            document.getElementById('tts-speed-slider').value = settings.ttsSpeed;
            document.getElementById('tts-speed-value').textContent = `${settings.ttsSpeed}x`;
        }
        
        if (settings.ttsAutoplay !== undefined) {
            document.getElementById('tts-autoplay-toggle').checked = settings.ttsAutoplay;
        }
        
    } catch (error) {
        console.error('Error loading TTS settings:', error);
        showToastMessage('Failed to load TTS settings', 'danger');
    }
}

function updateSpeedValue(value) {
    document.getElementById('tts-speed-value').textContent = `${value}x`;
}

function updateVoicePreview() {
    // Stop any currently playing audio
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
        document.getElementById('tts-preview-btn').style.display = 'inline-block';
        document.getElementById('tts-stop-btn').style.display = 'none';
    }
}

async function playVoicePreview() {
    const voiceSelect = document.getElementById('tts-voice-select');
    const selectedVoice = voiceSelect.value;
    
    if (!selectedVoice) {
        showToastMessage('Please select a voice first', 'warning');
        return;
    }
    
    const speed = parseFloat(document.getElementById('tts-speed-slider').value);
    const previewBtn = document.getElementById('tts-preview-btn');
    const stopBtn = document.getElementById('tts-stop-btn');
    const statusSpan = document.getElementById('tts-preview-status');
    
    try {
        previewBtn.disabled = true;
        statusSpan.textContent = 'Generating audio...';
        
        // Get voice name for display
        const voice = ttsVoices.find(v => v.name === selectedVoice);
        const displayName = voice ? voice.name.split(':')[0].split('-').pop() : 'voice';
        
        const sampleText = `Hi, I'm ${displayName}. This is how I sound when reading AI assistant messages.`;
        
        const response = await fetch('/api/chat/tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                text: sampleText,
                voice: selectedVoice,
                speed: speed
            })
        });
        
        if (!response.ok) {
            throw new Error('Failed to generate audio');
        }
        
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        
        currentAudio = new Audio(audioUrl);
        currentAudio.onplay = () => {
            previewBtn.style.display = 'none';
            stopBtn.style.display = 'inline-block';
            statusSpan.textContent = 'Playing...';
        };
        currentAudio.onended = () => {
            previewBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            previewBtn.disabled = false;
            statusSpan.textContent = '';
            URL.revokeObjectURL(audioUrl);
        };
        currentAudio.onerror = () => {
            previewBtn.style.display = 'inline-block';
            stopBtn.style.display = 'none';
            previewBtn.disabled = false;
            statusSpan.textContent = '';
            showToastMessage('Error playing audio', 'danger');
        };
        
        currentAudio.play();
        
    } catch (error) {
        console.error('Error playing voice preview:', error);
        showToastMessage('Failed to play voice preview', 'danger');
        previewBtn.disabled = false;
        statusSpan.textContent = '';
    }
}

function stopVoicePreview() {
    if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
        document.getElementById('tts-preview-btn').style.display = 'inline-block';
        document.getElementById('tts-stop-btn').style.display = 'none';
        document.getElementById('tts-preview-status').textContent = '';
    }
}

async function saveTTSSettings() {
    const voiceSelect = document.getElementById('tts-voice-select');
    const selectedVoice = voiceSelect.value;
    
    if (!selectedVoice) {
        showToastMessage('Please select a voice', 'warning');
        return;
    }
    
    const speed = parseFloat(document.getElementById('tts-speed-slider').value);
    const autoplay = document.getElementById('tts-autoplay-toggle').checked;
    
    try {
        const response = await fetch('/api/user/settings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                settings: {
                    ttsVoice: selectedVoice,
                    ttsSpeed: speed,
                    ttsAutoplay: autoplay,
                    ttsEnabled: true
                }
            })
        });
        
        if (!response.ok) {
            throw new Error('Failed to save settings');
        }
        
        showToastMessage('Text-to-speech settings saved successfully', 'success');
        
    } catch (error) {
        console.error('Error saving TTS settings:', error);
        showToastMessage('Failed to save TTS settings', 'danger');
    }
}
{% endif %}
</script>

<style>
.spinning {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>

{% endblock %}
